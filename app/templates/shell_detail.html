{% extends 'base.html' %}
{% block title %}{{ shell.name }}{% endblock %}
{% block content %}
<section class="card">
  <div class="card-header">
    <h2>Shell: {{ shell.name }}</h2>
    <div class="toolbar">
      {% if current_user.role == 'admin' %}
      <a href="{{ url_for('main.edit_shell', shell_id=shell.id) }}" class="btn ghost">Edit</a>
      {% endif %}
      <button type="button" class="btn ghost" id="btn-disconnect" title="Forcefully disconnect this shell">‚èè Disconnect</button>
      <a href="{{ url_for('main.shells_dashboard') }}" class="btn ghost">Back to Shells</a>
    </div>
  </div>

  <div class="host-info-bar">
    <span class="info-item"><strong>Address:</strong> <code>{{ shell.address }}:{{ shell.port }}</code></span>
    <span class="info-item"><strong>Group:</strong> {{ shell.group_name }}</span>
    <span class="info-item"><strong>Platform:</strong> {{ shell.platform or 'Unknown' }}</span>
    <span class="info-item"><strong>Hostname:</strong> {{ shell.hostname or '-' }}</span>
  </div>
</section>

{# Disconnect warning banner (hidden when connected) #}
<div class="term-disconnect-banner" id="term-disconnect-banner" {% if is_connected %}style="display:none"{% endif %}>
  <span class="warn-icon">‚ö†Ô∏è</span>
  <span class="warn-text">
    <strong>Shell is disconnected</strong>
    <small>The terminal will resume automatically when the shell reconnects. You can also press Ctrl+Shift+R.</small>
  </span>
</div>

{# Real-time xterm.js terminal with tabs #}
<div class="term-wrap" id="term-wrap">
  <div class="term-titlebar">
    <div class="term-dots"><span class="d-r"></span><span class="d-y"></span><span class="d-g"></span></div>
    <span class="term-title">{{ shell.shell_user or 'shell' }}@{{ shell.hostname or shell.address }} ‚Äî Reverse Shell</span>
    <span class="term-status">
      <span class="term-dot {% if is_connected %}online{% else %}offline{% endif %}" id="term-status-dot"></span>
      <span id="term-status-text">{% if is_connected %}Connected{% else %}Disconnected{% endif %}</span>
    </span>
    <div class="term-actions">
      <button type="button" id="btn-fullscreen" title="Toggle fullscreen (F11)">‚õ∂ Fullscreen</button>
      <button type="button" id="btn-reconnect" title="Reconnect terminal (Ctrl+Shift+R)">üîÑ Reconnect</button>
      <button type="button" id="btn-copy" title="Copy terminal output (Ctrl+Shift+C)">üìã Copy</button>
    </div>
  </div>
  <div class="term-tab-bar" id="term-tab-bar">
    <button class="term-tab active" data-tab="0">Session 1</button>
    <button class="term-tab-add" id="btn-new-tab" title="New session tab (Ctrl+Shift+T)">+</button>
  </div>
  <div id="xterm-container" style="background:#1a1b26;"></div>
</div>

{% if old_executions %}
<button class="scroll-to-history" onclick="document.getElementById('history-section').scrollIntoView({behavior:'smooth'})">
  ‚Üì Scroll to command history ({{ old_executions|length }} entries)
</button>
<section class="card" id="history-section" style="margin-top:0.5rem;">
  <div class="card-header">
    <h3>Command History (older sessions)</h3>
    {% if current_user.role == 'admin' %}
    <button type="button" class="btn ghost" id="btn-clear-history" style="color:#f44336;">üóëÔ∏è Clear History</button>
    {% endif %}
  </div>
  <div class="terminal-history">
    <div class="terminal-history-body">
      {% for run in old_executions %}
      <div class="terminal-entry">
        <div class="terminal-entry-meta">
          <span class="pill {{ run.status }}">{{ run.status }}</span>
          <span>{{ run.started_at.strftime('%Y-%m-%d %H:%M:%S') }}</span>
        </div>
        <div class="terminal-prompt">{{ run.command }}</div>
        {% if run.output %}<div class="terminal-stdout">{{ run.output }}</div>{% endif %}
      </div>
      {% endfor %}
    </div>
  </div>
</section>
{% endif %}

{# xterm.js local vendor files #}
<link rel="stylesheet" href="{{ url_for('static', filename='vendor/xterm.css') }}">
<script src="{{ url_for('static', filename='vendor/xterm.min.js') }}"></script>
<script src="{{ url_for('static', filename='vendor/addon-fit.min.js') }}"></script>
<script src="{{ url_for('static', filename='vendor/addon-web-links.min.js') }}"></script>
<script src="{{ url_for('static', filename='vendor/socket.io.min.js') }}"></script>
<script>
(function() {
  'use strict';

  const SHELL_ID = {{ shell.id }};
  const IS_CONNECTED = {{ 'true' if is_connected else 'false' }};
  const SHELL_LABEL = '{{ shell.shell_user or "shell" }}@{{ shell.hostname or shell.address }}';

  /* ‚îÄ‚îÄ Tab management ‚îÄ‚îÄ */
  const tabs = [];
  let activeTabId = -1;
  let nextTabId = 0;
  const tabBar = document.getElementById('term-tab-bar');
  const termContainer = document.getElementById('xterm-container');

  /* ‚îÄ‚îÄ Status UI ‚îÄ‚îÄ */
  const statusDot = document.getElementById('term-status-dot');
  const statusText = document.getElementById('term-status-text');
  const banner = document.getElementById('term-disconnect-banner');

  function setStatus(connected) {
    if (statusDot) statusDot.className = 'term-dot ' + (connected ? 'online' : 'offline');
    if (statusText) statusText.textContent = connected ? 'Connected' : 'Disconnected';
    if (banner) banner.style.display = connected ? 'none' : 'flex';
  }

  function getActiveTab() {
    return tabs.find(function(t) { return t.id === activeTabId; });
  }

  /* Create xterm.js terminal options */
  function makeTermOpts() {
    return {
      cursorBlink: true,
      fontSize: 14,
      fontFamily: "'SF Mono', Monaco, Menlo, 'Courier New', monospace",
      theme: {
        background: '#1a1b26',
        foreground: '#c0caf5',
        cursor: '#c0caf5',
        selectionBackground: '#33467c',
        black: '#15161e', red: '#f7768e', green: '#9ece6a', yellow: '#e0af68',
        blue: '#7aa2f7', magenta: '#bb9af7', cyan: '#7dcfff', white: '#a9b1d6',
      },
      scrollback: 10000,
      allowProposedApi: true,
    };
  }

  /* Status polling for disconnected shells */
  let pollTimer = null;
  function startStatusPolling(tab) {
    if (pollTimer) return;
    pollTimer = setInterval(function() {
      fetch('{{ url_for("main.shell_status_api", shell_id=shell.id) }}')
        .then(function(r) { return r.json(); })
        .then(function(d) {
          if (d.connected) {
            clearInterval(pollTimer);
            pollTimer = null;
            tab.connected = true;
            setStatus(true);
            tab.term.write('\r\n‚úì Shell reconnected!\r\n');
            tab.socket.emit('reverse_connect', { shell_id: SHELL_ID, cols: tab.term.cols, rows: tab.term.rows });
          }
        })
        .catch(function() {});
    }, 5000);
  }

  /* Create a new terminal tab */
  function createTab() {
    const id = nextTabId++;
    const num = tabs.length + 1;

    /* ‚îÄ‚îÄ Pane ‚îÄ‚îÄ */
    const pane = document.createElement('div');
    pane.className = 'xterm-tab-pane';
    pane.style.display = 'none';
    pane.style.background = '#1a1b26';
    termContainer.appendChild(pane);

    /* ‚îÄ‚îÄ xterm ‚îÄ‚îÄ */
    const term = new window.Terminal(makeTermOpts());
    const fitAddon = new window.FitAddon.FitAddon();
    term.loadAddon(fitAddon);
    try {
      const webLinksAddon = new window.WebLinksAddon.WebLinksAddon();
      term.loadAddon(webLinksAddon);
    } catch(e) {}
    term.open(pane);

    /* ‚îÄ‚îÄ SocketIO connection ‚îÄ‚îÄ */
    const sock = io({ transports: ['polling', 'websocket'] });
    const tab = { id: id, term: term, fitAddon: fitAddon, socket: sock, connected: false, pane: pane, el: null };

    /* Wire events */
    sock.on('connect', function() {
      if (IS_CONNECTED || tab.connected) {
        term.write('\r\nConnecting to ' + SHELL_LABEL + ' (Session ' + num + ')...\r\n');
        sock.emit('reverse_connect', { shell_id: SHELL_ID, cols: term.cols, rows: term.rows });
      }
    });

    sock.on('shell_output', function(data) {
      if (data.data) term.write(data.data);
    });

    sock.on('shell_status', function(data) {
      tab.connected = data.connected;
      if (tab.id === activeTabId) setStatus(data.connected);
      if (!data.connected) startStatusPolling(tab);
    });

    term.onData(function(data) {
      if (tab.connected) sock.emit('reverse_input', { data: data });
    });

    term.onResize(function(size) {
      sock.emit('reverse_resize', { cols: size.cols, rows: size.rows });
    });

    /* Keyboard shortcuts */
    term.attachCustomKeyEventHandler(function(e) {
      if (e.type !== 'keydown') return true;
      const ctrl = e.ctrlKey, shift = e.shiftKey;
      if (ctrl && shift) {
        switch (e.key) {
          case 'C':
            e.preventDefault();
            const sel = term.getSelection();
            if (sel) navigator.clipboard.writeText(sel);
            return false;
          case 'V':
            e.preventDefault();
            navigator.clipboard.readText().then(function(text) {
              if (tab.connected) sock.emit('reverse_input', { data: text });
            }).catch(function() {});
            return false;
          case 'T':
            e.preventDefault();
            createTab();
            return false;
          case 'W':
            e.preventDefault();
            closeTab(tab.id);
            return false;
          case 'R':
            e.preventDefault();
            reconnectTab(tab);
            return false;
        }
        const n = parseInt(e.key, 10);
        if (n >= 1 && n <= 9 && n <= tabs.length) {
          e.preventDefault();
          switchTab(tabs[n - 1].id);
          return false;
        }
      }
      return true;
    });

    /* ‚îÄ‚îÄ Tab button ‚îÄ‚îÄ */
    const tabBtn = document.createElement('button');
    tabBtn.className = 'term-tab';
    tabBtn.setAttribute('data-tab', id);
    tabBtn.innerHTML = 'Session ' + num + ' <span class="tab-close" title="Close tab">&times;</span>';
    tabBtn.addEventListener('click', function(e) {
      if (e.target.classList.contains('tab-close')) {
        closeTab(id);
      } else {
        switchTab(id);
      }
    });
    tab.el = tabBtn;

    tabBar.insertBefore(tabBtn, document.getElementById('btn-new-tab'));
    tabs.push(tab);
    switchTab(id);

    if (!IS_CONNECTED) {
      term.write('\r\n‚ö† Shell is disconnected. Waiting for reconnection...\r\n');
      startStatusPolling(tab);
    }

    return tab;
  }

  function switchTab(id) {
    tabs.forEach(function(t) {
      const isActive = t.id === id;
      t.pane.style.display = isActive ? 'block' : 'none';
      t.el.classList.toggle('active', isActive);
      if (isActive) {
        t.fitAddon.fit();
        t.term.focus();
        setStatus(t.connected);
      }
    });
    activeTabId = id;
  }

  function closeTab(id) {
    if (tabs.length <= 1) return;
    const idx = tabs.findIndex(function(t) { return t.id === id; });
    if (idx < 0) return;
    const tab = tabs[idx];
    tab.socket.emit('reverse_disconnect_host', { shell_id: SHELL_ID });
    tab.socket.disconnect();
    tab.term.dispose();
    tab.pane.remove();
    tab.el.remove();
    tabs.splice(idx, 1);
    if (activeTabId === id) {
      switchTab(tabs[Math.min(idx, tabs.length - 1)].id);
    }
  }

  function reconnectTab(tab) {
    if (!tab) tab = getActiveTab();
    if (!tab) return;
    tab.term.write('\r\n--- Reconnecting ---\r\n');
    fetch('{{ url_for("main.shell_status_api", shell_id=shell.id) }}')
      .then(function(r) { return r.json(); })
      .then(function(d) {
        if (d.connected) {
          tab.connected = true;
          setStatus(true);
          tab.socket.emit('reverse_connect', { shell_id: SHELL_ID, cols: tab.term.cols, rows: tab.term.rows });
          tab.term.write('\r\n‚úì Reconnected!\r\n');
        } else {
          tab.term.write('\r\n‚ö† Shell is still disconnected\r\n');
          startStatusPolling(tab);
        }
      })
      .catch(function() { tab.term.write('\r\n‚ö† Could not check status\r\n'); });
  }

  /* Remove default first tab button */
  const defaultTabBtn = tabBar.querySelector('[data-tab="0"]');
  if (defaultTabBtn) defaultTabBtn.remove();

  /* Create first tab */
  createTab();

  /* Resize on window resize */
  window.addEventListener('resize', function() {
    const tab = getActiveTab();
    if (tab) tab.fitAddon.fit();
  });

  /* ‚îÄ‚îÄ Fullscreen ‚îÄ‚îÄ */
  document.getElementById('btn-fullscreen').addEventListener('click', function() {
    const wrap = document.getElementById('term-wrap');
    if (document.fullscreenElement) {
      document.exitFullscreen();
    } else if (wrap.classList.contains('fullscreen')) {
      /* Exit CSS fallback fullscreen */
      wrap.classList.remove('fullscreen');
      setTimeout(function() {
        const tab = getActiveTab();
        if (tab) tab.fitAddon.fit();
      }, 200);
    } else {
      wrap.requestFullscreen().then(function() {
        setTimeout(function() {
          const tab = getActiveTab();
          if (tab) tab.fitAddon.fit();
        }, 200);
      }).catch(function() {
        /* Fallback: use CSS class */
        wrap.classList.add('fullscreen');
        setTimeout(function() {
          const tab = getActiveTab();
          if (tab) tab.fitAddon.fit();
        }, 200);
      });
    }
  });
  document.addEventListener('fullscreenchange', function() {
    setTimeout(function() {
      const tab = getActiveTab();
      if (tab) tab.fitAddon.fit();
    }, 200);
  });

  /* ‚îÄ‚îÄ New tab button ‚îÄ‚îÄ */
  document.getElementById('btn-new-tab').addEventListener('click', function() { createTab(); });

  /* ‚îÄ‚îÄ Top bar buttons ‚îÄ‚îÄ */
  document.getElementById('btn-disconnect').addEventListener('click', function() {
    const tab = getActiveTab();
    if (!tab) return;
    if (confirm('Forcefully disconnect this shell?')) {
      tab.socket.emit('reverse_disconnect_host', { shell_id: SHELL_ID });
      tab.connected = false;
      setStatus(false);
    }
  });

  document.getElementById('btn-reconnect').addEventListener('click', function() { reconnectTab(); });

  document.getElementById('btn-copy').addEventListener('click', function() {
    const tab = getActiveTab();
    if (!tab) return;
    const text = (function() {
      const lines = [];
      for (let i = 0; i < tab.term.buffer.active.length; i++) {
        const line = tab.term.buffer.active.getLine(i);
        if (line) lines.push(line.translateToString(true));
      }
      return lines.join('\n');
    })();
    navigator.clipboard.writeText(text).then(function() {
      const btn = document.getElementById('btn-copy');
      const orig = btn.textContent;
      btn.textContent = '‚úì Copied!';
      setTimeout(function() { btn.textContent = orig; }, 1500);
    });
  });

  /* Clear history button */
  const clearBtn = document.getElementById('btn-clear-history');
  if (clearBtn) {
    clearBtn.addEventListener('click', function() {
      if (!confirm('Clear all command history for this shell?')) return;
      fetch('{{ url_for("main.clear_shell_history", shell_id=shell.id) }}', {
        method: 'POST',
        headers: { 'X-CSRFToken': '{{ csrf_token() }}' },
      })
      .then(function(r) { return r.json(); })
      .then(function(d) {
        if (d.success) {
          const section = clearBtn.closest('section');
          if (section) section.remove();
          const scrollBtn = document.querySelector('.scroll-to-history');
          if (scrollBtn) scrollBtn.remove();
        }
      })
      .catch(function(e) { alert('Error clearing history: ' + e); });
    });
  }
})();
</script>
{% endblock %}
