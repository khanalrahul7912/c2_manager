{% extends 'base.html' %}
{% block title %}{{ shell.name }}{% endblock %}
{% block content %}
<section class="card">
  <div class="card-header">
    <h2>Shell: {{ shell.name }}</h2>
    <div class="toolbar">
      {% if current_user.role == 'admin' %}
      <a href="{{ url_for('main.edit_shell', shell_id=shell.id) }}" class="btn ghost">Edit</a>
      {% endif %}
      <button type="button" class="btn ghost" id="btn-disconnect" title="Forcefully disconnect this shell">‚èè Disconnect</button>
      <a href="{{ url_for('main.shells_dashboard') }}" class="btn ghost">Back to Shells</a>
    </div>
  </div>

  <div class="host-info-bar">
    <span class="info-item"><strong>Address:</strong> <code>{{ shell.address }}:{{ shell.port }}</code></span>
    <span class="info-item"><strong>Group:</strong> {{ shell.group_name }}</span>
    <span class="info-item"><strong>Platform:</strong> {{ shell.platform or 'Unknown' }}</span>
    <span class="info-item"><strong>Hostname:</strong> {{ shell.hostname or '-' }}</span>
  </div>
</section>

{# Disconnect warning banner (hidden when connected) #}
<div class="term-disconnect-banner" id="term-disconnect-banner" {% if is_connected %}style="display:none"{% endif %}>
  <span class="warn-icon">‚ö†Ô∏è</span>
  <span class="warn-text">
    <strong>Shell is disconnected</strong>
    <small>The terminal will resume automatically when the shell reconnects. You can also press Ctrl+Shift+R.</small>
  </span>
</div>

{# Real-time xterm.js terminal #}
<div class="term-wrap">
  <div class="term-titlebar">
    <div class="term-dots"><span class="d-r"></span><span class="d-y"></span><span class="d-g"></span></div>
    <span class="term-title">{{ shell.shell_user or 'shell' }}@{{ shell.hostname or shell.address }} ‚Äî Reverse Shell</span>
    <span class="term-status">
      <span class="term-dot {% if is_connected %}online{% else %}offline{% endif %}" id="term-status-dot"></span>
      <span id="term-status-text">{% if is_connected %}Connected{% else %}Disconnected{% endif %}</span>
    </span>
    <div class="term-actions">
      <button type="button" id="btn-reconnect" title="Reconnect terminal (Ctrl+Shift+R)">üîÑ Reconnect</button>
      <button type="button" id="btn-copy" title="Copy terminal output (Ctrl+Shift+C)">üìã Copy</button>
    </div>
  </div>
  <div id="xterm-container" style="background:#1a1b26;"></div>
</div>

{% if old_executions %}
<button class="scroll-to-history" onclick="document.getElementById('history-section').scrollIntoView({behavior:'smooth'})">
  ‚Üì Scroll to command history ({{ old_executions|length }} entries)
</button>
<section class="card" id="history-section" style="margin-top:0.5rem;">
  <div class="card-header">
    <h3>Command History (older sessions)</h3>
    {% if current_user.role == 'admin' %}
    <button type="button" class="btn ghost" id="btn-clear-history" style="color:#f44336;">üóëÔ∏è Clear History</button>
    {% endif %}
  </div>
  <div class="terminal-history">
    <div class="terminal-history-body">
      {% for run in old_executions %}
      <div class="terminal-entry">
        <div class="terminal-entry-meta">
          <span class="pill {{ run.status }}">{{ run.status }}</span>
          <span>{{ run.started_at.strftime('%Y-%m-%d %H:%M:%S') }}</span>
        </div>
        <div class="terminal-prompt">{{ run.command }}</div>
        {% if run.output %}<div class="terminal-stdout">{{ run.output }}</div>{% endif %}
      </div>
      {% endfor %}
    </div>
  </div>
</section>
{% endif %}

{# xterm.js local vendor files #}
<link rel="stylesheet" href="{{ url_for('static', filename='vendor/xterm.css') }}">
<script src="{{ url_for('static', filename='vendor/xterm.min.js') }}"></script>
<script src="{{ url_for('static', filename='vendor/addon-fit.min.js') }}"></script>
<script src="{{ url_for('static', filename='vendor/addon-web-links.min.js') }}"></script>
<script src="{{ url_for('static', filename='vendor/socket.io.min.js') }}"></script>
<script>
(function() {
  'use strict';

  const SHELL_ID = {{ shell.id }};
  const IS_CONNECTED = {{ 'true' if is_connected else 'false' }};

  /* ‚îÄ‚îÄ xterm.js setup ‚îÄ‚îÄ */
  const term = new window.Terminal({
    cursorBlink: true,
    fontSize: 14,
    fontFamily: "'SF Mono', Monaco, Menlo, 'Courier New', monospace",
    theme: {
      background: '#1a1b26',
      foreground: '#c0caf5',
      cursor: '#c0caf5',
      selectionBackground: '#33467c',
      black: '#15161e', red: '#f7768e', green: '#9ece6a', yellow: '#e0af68',
      blue: '#7aa2f7', magenta: '#bb9af7', cyan: '#7dcfff', white: '#a9b1d6',
    },
    scrollback: 10000,
    allowProposedApi: true,
  });

  const fitAddon = new window.FitAddon.FitAddon();
  term.loadAddon(fitAddon);
  try {
    const webLinksAddon = new window.WebLinksAddon.WebLinksAddon();
    term.loadAddon(webLinksAddon);
  } catch(e) {}

  const container = document.getElementById('xterm-container');
  term.open(container);
  fitAddon.fit();

  window.addEventListener('resize', function() { fitAddon.fit(); });

  /* ‚îÄ‚îÄ Keyboard shortcuts ‚îÄ‚îÄ */
  term.attachCustomKeyEventHandler(function(e) {
    if (e.type !== 'keydown') return true;
    const ctrl = e.ctrlKey, shift = e.shiftKey;
    if (ctrl && shift) {
      switch (e.key) {
        case 'C':
          e.preventDefault();
          const sel = term.getSelection();
          if (sel) navigator.clipboard.writeText(sel);
          return false;
        case 'V':
          e.preventDefault();
          navigator.clipboard.readText().then(function(text) {
            if (connected) socket.emit('reverse_input', { data: text });
          }).catch(function() {});
          return false;
        case 'R':
          e.preventDefault();
          doReconnect();
          return false;
      }
    }
    return true;
  });

  /* ‚îÄ‚îÄ Status UI ‚îÄ‚îÄ */
  const statusDot = document.getElementById('term-status-dot');
  const statusText = document.getElementById('term-status-text');
  const banner = document.getElementById('term-disconnect-banner');

  function setStatus(conn) {
    if (statusDot) statusDot.className = 'term-dot ' + (conn ? 'online' : 'offline');
    if (statusText) statusText.textContent = conn ? 'Connected' : 'Disconnected';
    if (banner) banner.style.display = conn ? 'none' : 'flex';
  }

  /* ‚îÄ‚îÄ SocketIO ‚îÄ‚îÄ */
  const socket = io({ transports: ['polling', 'websocket'] });
  let connected = false;

  function connectShell() {
    socket.emit('reverse_connect', {
      shell_id: SHELL_ID,
      cols: term.cols,
      rows: term.rows,
    });
  }

  socket.on('connect', function() {
    if (IS_CONNECTED || connected) {
      connectShell();
    }
  });

  socket.on('shell_output', function(data) {
    if (data.data) {
      term.write(data.data);
    }
  });

  socket.on('shell_status', function(data) {
    connected = data.connected;
    setStatus(connected);
  });

  /* Send user input to shell */
  term.onData(function(data) {
    if (connected) {
      socket.emit('reverse_input', { data: data });
    }
  });

  /* Terminal resize */
  term.onResize(function(size) {
    socket.emit('reverse_resize', { cols: size.cols, rows: size.rows });
  });

  /* Initial connect */
  if (IS_CONNECTED) {
    connectShell();
  } else {
    term.write('\r\n‚ö† Shell is disconnected. Waiting for reconnection...\r\n');
    setInterval(function() {
      if (!connected) {
        fetch('{{ url_for("main.shell_status_api", shell_id=shell.id) }}')
          .then(function(r) { return r.json(); })
          .then(function(d) {
            if (d.connected && !connected) {
              connected = true;
              setStatus(true);
              term.write('\r\n‚úì Shell reconnected!\r\n');
              connectShell();
            }
          })
          .catch(function() {});
      }
    }, 5000);
  }

  function doReconnect() {
    if (!connected) {
      fetch('{{ url_for("main.shell_status_api", shell_id=shell.id) }}')
        .then(function(r) { return r.json(); })
        .then(function(d) {
          if (d.connected) {
            connected = true;
            setStatus(true);
            connectShell();
            term.write('\r\n‚úì Reconnected!\r\n');
          } else {
            term.write('\r\n‚ö† Shell is still disconnected\r\n');
          }
        });
    } else {
      connectShell();
      term.write('\r\n‚úì Terminal re-attached\r\n');
    }
  }

  /* ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ */
  document.getElementById('btn-disconnect').addEventListener('click', function() {
    if (confirm('Forcefully disconnect this shell?')) {
      socket.emit('reverse_disconnect_host', { shell_id: SHELL_ID });
      connected = false;
      setStatus(false);
    }
  });

  document.getElementById('btn-reconnect').addEventListener('click', doReconnect);

  document.getElementById('btn-copy').addEventListener('click', function() {
    const text = term.buffer.active.getLine(0) ? (function() {
      const lines = [];
      for (let i = 0; i < term.buffer.active.length; i++) {
        const line = term.buffer.active.getLine(i);
        if (line) lines.push(line.translateToString(true));
      }
      return lines.join('\n');
    })() : '';
    navigator.clipboard.writeText(text).then(function() {
      const btn = document.getElementById('btn-copy');
      const orig = btn.textContent;
      btn.textContent = '‚úì Copied!';
      setTimeout(function() { btn.textContent = orig; }, 1500);
    });
  });

  /* Clear history button */
  const clearBtn = document.getElementById('btn-clear-history');
  if (clearBtn) {
    clearBtn.addEventListener('click', function() {
      if (!confirm('Clear all command history for this shell?')) return;
      fetch('{{ url_for("main.clear_shell_history", shell_id=shell.id) }}', {
        method: 'POST',
        headers: { 'X-CSRFToken': '{{ csrf_token() }}' },
      })
      .then(function(r) { return r.json(); })
      .then(function(d) {
        if (d.success) {
          const section = clearBtn.closest('section');
          if (section) section.remove();
          const scrollBtn = document.querySelector('.scroll-to-history');
          if (scrollBtn) scrollBtn.remove();
        }
      })
      .catch(function(e) { alert('Error clearing history: ' + e); });
    });
  }
})();
</script>
{% endblock %}
